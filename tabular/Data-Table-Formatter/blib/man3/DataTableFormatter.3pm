.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Table::Formatter 3"
.TH Data::Table::Formatter 3 "2010-01-19" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Table::Formatter \- Formats tabular data using ASCII, CSV, Fixed\-width, HTML, JSON, LaTeX, TSV, Wiki, XML, and YAML layouts.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides formatting for tabular data using a variety of common formats, serializations, and markup languages.  It is designed to easily accommodate the most prevalent use cases of tabular formatting.
.Sh "\s-1DESIGN\s0 \s-1CONSIDERATIONS\s0"
.IX Subsection "DESIGN CONSIDERATIONS"
Keeping with the \s-1UNIX\s0 philosophy of \*(L"do one thing and do it well,\*(R" what Data::Table::Formatter \fIdoesn't\fR do is manipulate your data.  All it does is formatting.  It assumes that you know how you want your data structured, and only need some presentation sugar applied to fit into a target environment(s).  You can hand it data as a two-dimensional array or as an array reference of hash references, or both concurrently.
.PP
If you're looking for a tabular data module to help you \fIstructure\fR your data, there are plenty of other modules on \s-1CPAN\s0 for that.  Check out Data::Table, Data::CTable, and Data::Tabular.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
There are two equivalent interfaces for this module.  The imperative interface works most quickly and simply to output a single table whereas the object oriented interface is designed to easily output a series of similarly formatted tables.
.Sh "\s-1IMPERATIVE\s0 \s-1INTERFACE\s0"
.IX Subsection "IMPERATIVE INTERFACE"
.Vb 1
\&        use Data::Table::Formatter;
\&
\&        print Data::Table::Formatter::build({
\&                layout  => \*(Aqascii\*(Aq,
\&                title => \*(AqSample Presentation Data\*(Aq,
\&                labels => [\*(Aqone\*(Aq, \*(Aqtwo\*(Aq, \*(Aqthree\*(Aq],
\&                data    => [
\&                        {one => \*(Aqalpha\*(Aq, two => \*(Aqbravo\*(Aq, three => \*(Aqcharlie\*(Aq},
\&                        {one => \*(Aqdelta\*(Aq, two => \*(Aqecho\*(Aq,  three => \*(Aqfoxtrot\*(Aq},
\&                        {one => \*(Aqgolf\*(Aq,  two => \*(Aqhotel\*(Aq, three => \*(Aqindia\*(Aq},
\&                ]
\&        });
.Ve
.Sh "OBJECT-ORIENTED \s-1INTERFACE\s0"
.IX Subsection "OBJECT-ORIENTED INTERFACE"
Through the \s-1OOP\s0 interface, you can pass your tabular data and preferences into the constructor:
.PP
.Vb 1
\&        use Data::Table::Formatter;
\&
\&        my $formatter = new Data::Table::Formatter({
\&                layout  => \*(Aqascii\*(Aq,
\&                title => \*(AqSample Presentation Data\*(Aq,
\&                labels => [\*(Aqone\*(Aq, \*(Aqtwo\*(Aq, \*(Aqthree\*(Aq],
\&                data    => [
\&                        {one => \*(Aqalpha\*(Aq, two => \*(Aqbravo\*(Aq, three => \*(Aqcharlie\*(Aq},
\&                        {one => \*(Aqdelta\*(Aq, two => \*(Aqecho\*(Aq,  three => \*(Aqfoxtrot\*(Aq},
\&                        {one => \*(Aqgolf\*(Aq,  two => \*(Aqhotel\*(Aq, three => \*(Aqindia\*(Aq},
\&                ]
\&        });
\&        
\&        print $formatter\->render();
.Ve
.PP
Alternatively, you can spin up the object and hand your data and preferences to the accessor methods:
.PP
.Vb 1
\&        use Data::Table::Formatter;
\&
\&        my $formatter = new Data::Table::Formatter();
\&        
\&        $formatter\->layout(\*(Aqascii\*(Aq);
\&        $formatter\->title(\*(AqSample Presentation Data\*(Aq);
\&        $formatter\->labels([\*(Aqone\*(Aq, \*(Aqtwo\*(Aq, \*(Aqthree\*(Aq]);
\&        
\&        $formatter\->data([
\&                {one => \*(Aqalpha\*(Aq, two => \*(Aqbravo\*(Aq, three => \*(Aqcharlie\*(Aq},
\&                {one => \*(Aqdelta\*(Aq, two => \*(Aqecho\*(Aq,  three => \*(Aqfoxtrot\*(Aq},
\&                {one => \*(Aqgolf\*(Aq,  two => \*(Aqhotel\*(Aq, three => \*(Aqindia\*(Aq},
\&        ]);
\&        
\&        print $formatter\->render();
.Ve
.PP
Of course, you can also mix these two approaches to fit your problem set.  All data and preferences handed to the formatter are preserved between calls to \fIrender()\fR.
.SH "LAYOUTS"
.IX Header "LAYOUTS"
.Sh "\s-1ASCII\s0"
.IX Subsection "ASCII"
The \s-1ASCII\s0 display modality constructs an \s-1ASCII\s0 art-style layout:
.PP
.Vb 9
\&        .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&        | Sample Presentation Data |
\&        |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&        | one   | two   | three    |
\&        |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&        | alpha | bravo | charlie  |
\&        | delta | echo  | foxtrot  |
\&        | golf  | hotel | india    |
\&        \*(Aq\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
.Ve
.PP
Note: the \s-1ASCII\s0 display modality takes one optional argument: no_labels.  If this is set to something that evaluates to true, the labels will be not be printed:
.PP
.Vb 10
\&        Data::Table::Formatter::build({
\&                layout  => \*(Aqascii\*(Aq,
\&                title => \*(AqSample Presentation Data\*(Aq,
\&                labels => [\*(Aqone\*(Aq, \*(Aqtwo\*(Aq, \*(Aqthree\*(Aq],
\&                data    => [
\&                        {one => \*(Aqalpha\*(Aq, two => \*(Aqbravo\*(Aq, three => \*(Aqcharlie\*(Aq},
\&                        {one => \*(Aqdelta\*(Aq, two => \*(Aqecho\*(Aq,  three => \*(Aqfoxtrot\*(Aq},
\&                        {one => \*(Aqgolf\*(Aq,  two => \*(Aqhotel\*(Aq, three => \*(Aqindia\*(Aq},
\&                ]
\&        });
.Ve
.Sh "\s-1CSV\s0"
.IX Subsection "CSV"
Not yet implemented
.Sh "Fixed"
.IX Subsection "Fixed"
Not yet implemented
.Sh "\s-1HTML\s0"
.IX Subsection "HTML"
Not yet implemented
.Sh "\s-1JSON\s0"
.IX Subsection "JSON"
Not yet implemented
.Sh "LaTeX"
.IX Subsection "LaTeX"
Not yet implemented
.Sh "\s-1TSV\s0"
.IX Subsection "TSV"
Not yet implemented
.Sh "Wiki"
.IX Subsection "Wiki"
Not yet implemented
.Sh "\s-1XML\s0"
.IX Subsection "XML"
Not yet implemented
.Sh "\s-1YAML\s0"
.IX Subsection "YAML"
Not yet implemented
.SH "OBJECT ORIENTED METHODS"
.IX Header "OBJECT ORIENTED METHODS"
.ie n .Sh """new"""
.el .Sh "\f(CWnew\fP"
.IX Subsection "new"
Constructor for Data::Table::Formatter objects
.PP
Takes:
.IP "\(bu" 4
(optional) \f(CW\*(C`configuration\*(C'\fR (hash reference), conaining:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`layout\*(C'\fR (scalar) \- an overall layout for the table ('ascii', 'csv', etc)
.IP "\(bu" 4
\&\f(CW\*(C`title\*(C'\fR (scalar) \- a title for the table
.IP "\(bu" 4
\&\f(CW\*(C`labels\*(C'\fR (array reference) \- a set of labels for the data in the table
.IP "\(bu" 4
\&\f(CW\*(C`data\*(C'\fR (array reference) \- a data set for the table
.RE
.RS 4
.RE
.PP
All of these configuration elements can also be handed to parallel accessor methods before finally calling \fIrender()\fR on the object to generate the table.
.ie n .Sh """layout"""
.el .Sh "\f(CWlayout\fP"
.IX Subsection "layout"
Accessor for the table's general layout.
.PP
Takes:
.IP "\(bu" 4
(optional) \f(CW\*(C`layout\*(C'\fR (scalar) \- Ideally, you would set this to one of 'ascii', 'csv', 'fixed\-width', 'html', 'json', 'latex', 'tsv', 'wiki', 'xml', or 'yaml'.
.PP
Returns:
.IP "\(bu" 4
\&\f(CW\*(C`layout\*(C'\fR (scalar) if you called this with no arguments (as a getter)
.IP "\(bu" 4
\&\f(CW$self\fR (Data::Table::Formatter) if you called this with an argument (as a setter)
.IP "\(bu" 4
\&\f(CW\*(C`undef()\*(C'\fR \- on any error.  Messages available through warn (for my problems) and carp (for yours).
.ie n .Sh """title"""
.el .Sh "\f(CWtitle\fP"
.IX Subsection "title"
Accessor for the table's general title.
.PP
Takes:
.IP "\(bu" 4
(optional) \f(CW\*(C`title\*(C'\fR (scalar) \- The title you want to give your table.
.PP
Returns:
.IP "\(bu" 4
\&\f(CW\*(C`title\*(C'\fR (scalar) if you called this with no arguments (as a getter)
.IP "\(bu" 4
\&\f(CW$self\fR (Data::Table::Formatter) if you called this with an argument (as a setter)
.IP "\(bu" 4
\&\f(CW\*(C`undef()\*(C'\fR \- on any error.  Messages available through warn (for my problems) and carp (for yours).
.ie n .Sh """labels"""
.el .Sh "\f(CWlabels\fP"
.IX Subsection "labels"
Accessor for the table's column labels.
.PP
Takes:
.IP "\(bu" 4
(optional) \f(CW\*(C`labels\*(C'\fR (array reference) \- The column labels you want to give your table.
.PP
Returns:
.IP "\(bu" 4
\&\f(CW\*(C`labels\*(C'\fR (array reference) if you called this with no arguments (as a getter)
.IP "\(bu" 4
\&\f(CW$self\fR (Data::Table::Formatter) if you called this with an argument (as a setter)
.IP "\(bu" 4
\&\f(CW\*(C`undef()\*(C'\fR \- on any error.  Messages available through warn (for my problems) and carp (for yours).
.ie n .Sh """data"""
.el .Sh "\f(CWdata\fP"
.IX Subsection "data"
Accessor for the table's data.
.PP
Takes:
.IP "\(bu" 4
(optional) \f(CW\*(C`data\*(C'\fR (array reference) \- The column data you want to give your table.
.PP
Returns:
.IP "\(bu" 4
\&\f(CW\*(C`data\*(C'\fR (array reference) if you called this with no arguments (as a getter)
.IP "\(bu" 4
\&\f(CW$self\fR (Data::Table::Formatter) if you called this with an argument (as a setter)
.IP "\(bu" 4
\&\f(CW\*(C`undef()\*(C'\fR \- on any error.  Messages available through warn (for my problems) and carp (for yours).
.ie n .Sh """options"""
.el .Sh "\f(CWoptions\fP"
.IX Subsection "options"
Accessor for the table's formatter's options.
.PP
Takes:
.IP "\(bu" 4
(optional) \f(CW\*(C`options\*(C'\fR (hash reference) \- any formatter-specific options.
.PP
Returns:
.IP "\(bu" 4
\&\f(CW\*(C`options\*(C'\fR (hash reference) if you called this with no arguments (as a getter)
.IP "\(bu" 4
\&\f(CW$self\fR (Data::Table::Formatter) if you called this with an argument (as a setter)
.IP "\(bu" 4
\&\f(CW\*(C`undef()\*(C'\fR \- on any error.  Messages available through warn (for my problems) and carp (for yours).
.ie n .Sh """render"""
.el .Sh "\f(CWrender\fP"
.IX Subsection "render"
Final method used to construct and returns the formatted table.
.PP
If you don't set the format before calling \fIrender()\fR, it will assume you want 'ascii'.
.SH "IMPERATIVE FUNCTIONS"
.IX Header "IMPERATIVE FUNCTIONS"
.ie n .Sh """build"""
.el .Sh "\f(CWbuild\fP"
.IX Subsection "build"
Procedural function to construct and return a formatted table
.PP
Takes:
.IP "\(bu" 4
\&\f(CW\*(C`configuration\*(C'\fR (hash reference), conaining:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`labels\*(C'\fR (array reference) \- a set of labels for the data in the table
.IP "\(bu" 4
\&\f(CW\*(C`data\*(C'\fR (array reference) \- a data set for the table
.IP "\(bu" 4
(optional) \f(CW\*(C`layout\*(C'\fR (scalar) \- an overall layout for the table ('ascii', 'csv', etc).  Will assume 'ascii' if not set.
.IP "\(bu" 4
(optional) \f(CW\*(C`title\*(C'\fR (scalar) \- a title for the table
.IP "\(bu" 4
(optional) \f(CW\*(C`options\*(C'\fR (hash reference) \- any optional formatter-specific parameters
.RE
.RS 4
.RE
.PP
All of these configuration elements can also be handed to parallel accessor methods before finally calling \fIrender()\fR on the object to generate the table.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dann Stayskal, \f(CW\*(C`<dann at stayskal.com>\*(C'\fR
.SH "BUGS AND FEATURE REQUESTS"
.IX Header "BUGS AND FEATURE REQUESTS"
Before notifying me of any bugs or requesting any new features, please check the listing on \s-1RT\s0, \s-1CPAN\s0's request tracker:
.PP
.Vb 1
\&    L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Data\-Table\-Formatter>
.Ve
.PP
Once you've verified that your bug has not yet been reported or your feature requested, please report it to \f(CW\*(C`bug\-data\-table\-formatter at rt.cpan.org\*(C'\fR, or through the web interface above.  It will notify me, and you'll automatically be notified of progress on your bug or feature as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Data::Table::Formatter
.Ve
.PP
Additionally, support and documentation is available on the Data::Table::Formatter website:
.PP
.Vb 1
\&        L<http://dann.stayskal.com/software/data\-table\-formatter>
.Ve
.PP
To annotate the documentation for this module, visit AnnoCPAN, Annotated \s-1CPAN\s0 documentation:
.PP
.Vb 1
\&    L<http://annocpan.org/dist/Data\-Table\-Formatter>
.Ve
.PP
Finally, if you like or dislike this module, please rate it constructively at \s-1CPAN\s0 Ratings:
.PP
.Vb 1
\&    L<http://cpanratings.perl.org/d/Data\-Table\-Formatter>
.Ve
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2004\-2010 Dann Stayskal.  Very few rights reserved:
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either: the \s-1GNU\s0 General Public License as published
by the Free Software Foundation; or the Artistic License.
.PP
See <http://dev.perl.org/licenses/> for more information.
